---
title: 【JVM 笔记】JVM 内存结构
categories:
  - tech
tags:
  - jvm
comments: true
date: 2019-04-26 22:07:41
updated: 2021-03-15 13:09:35
---

![](https://img.mubu.com/document_image/9bf16aec-c66f-4159-9463-93a95c33e7ac-3011473.jpg)

<!-- more -->

### 组成

- 运行时数据区（JVM Run-Time Data Areas ）
    - 程序计数器（Program Counter Register）
    - Java 虚拟机栈（JVM Stack）
    - 本地方法栈（Native Method Stack）
    - Java 堆（Java Heap）
    - 方法区（Method Area）
    - 运行时常量池（Runtime Constant Pool）
- 直接内存（Direct Memory）



线程隔离（私有）

- 程序计数器
      - 当前线程所执行的字节码的行号指示器，改变其值可以执行不同的字节码指令
          - 每条线程都有独立的程序计数器，在任意时刻，一条线程只会执行一个方法，被执行的方法被称作当前方法（current method）
          - 当前方法为 native 方法时：计数器值为空（undefiend）；当前方法为 Java 方法时：计数器记录的是正在执行的虚拟机字节码指令的地址
          - 唯一没有规定 OutOfMemoryError 的内存区域
  
  - Java虚拟机栈
      - 每条线程都有独立的虚拟机栈，生命周期和线程相同
      - 每个方法执行时会在 Java 虚拟机栈中创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等，方法的调用和执行对应着栈帧的入栈和出栈过程
      - 线程请求的栈深度大于虚拟机所允许的深度，会抛出 StackOverflowError 异常；当虚拟机栈允许动态扩展，但扩展时无法申请足够内存，会抛出 OutOfMemoryError 异常
  - 本地方法栈
      - 作用与虚拟机栈相似，区别在于虚拟机栈执行 Java 方法服务，本地方法栈执行 Native 方法服务
    - 异常和虚拟机栈相同
  
- 线程共享

- Java 堆

  ![](D:\Typora-images\32ad41f0-664c-4352-b3ee-22f915181e22-3011473.jpg)

- - 存放对象实例，几乎所有的对象实例（包括数组）都在此分配内存
    - 垃圾回收的主要区域，亦称作 “GC” 堆
    - Java 堆可以被细分为：新生代和老年代（Eden Space（伊甸园）、Survivor Space（ 幸存者区），Tenured Gen（老年代））
    - 在堆中没有足够内存完成实例分配，并且堆也无法在扩展时，会抛出 OutOfMemoryError 异常

- 方法区（别名：Non-Heap（非堆），Permanent Generation（永久代））

    - 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    - 当方法区无法满足内存分配需求时，会抛出 OutOfMemoryError 异常

- 运行时常量池

    - 该区域是方法区的一部分，存放常量池信息↓
    - 常量池用于存放编译期生成的各种字面量和符号引用
    - 异常同方法区

- 直接内存

    - 直接内存不是 Java 虚拟机规范中定义的内存区域，但是经常会用到
    - JDK 1.4 中新加入的 NIO，引入了通道与缓冲区的 IO 方式，它可以调用 Native 方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小

关于 JDK 1.8 中永久代被移除：

- 方法区和永久代之间有着本质的区别：前者是 JVM 的规范，后者是 JVM 规范的一种实现，并且只有 HotSpot 才有永久代（PermGen Space）
- 在 JDK 1.7 时就开始了移除永久代的工作，在 JDK 1.8 中被彻底移除，取而代之的是元空间（Meta Space）
- 元空间是一个与堆不相连的本地内存区域，元空间里存储的是元数据，类的层级信息，方法数据和方法信息（如字节码，栈和变量大小），运行时常量池，已确定的符号引用和虚方法表
- 原因
    - 字符串在永久代中，容易出现性能问题和内存溢出
    - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
    - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低